/*
 * This source file was generated by the Gradle 'init' task
 */
package iqw

import org.iqw.bin.Executor
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Assertions.fail
import org.junit.jupiter.api.assertThrows
import kotlin.test.Test
import kotlin.test.assertEquals
import java.io.IOException

/**
 * Test class for [Executor] to verify its ability to launch an
 * external command and store the output/error
 */
class ExecutorTest {

    /**
     * Test that [Executor] can find basic system executables.
     *
     * Execute the echo command
     * @throws IOException if the command "cmd" or "echo" cannot be found.
     */
    @Test fun executorCanFindBasicCommands() {
        val executor = Executor.ExecutorBuilder("cmd")
            .addArgs("/c", "echo")
            .build()
        executor.execute()
    }

    /**
     * Test that [Executor] errors as predicted when commands can't be found.
     *
     * Execute a non-existent command and verify an [IOException] is thrown with
     * a predictable format.
     */
    @Test fun executorFailsWhenCantFindCommand() {
        val problematicCommand = "not_a_command"
        val executor = Executor.ExecutorBuilder(problematicCommand)
            .build()

        val exception = assertThrows<IOException> {
            executor.execute()
        }

        val expectedExceptionMessage = "Cannot run program \"$problematicCommand\": CreateProcess error=2, The system cannot find the file specified"
        assertEquals(expectedExceptionMessage, exception.message)
    }

    /**
     * Test that [Executor] properly stores the output of a command.
     *
     * Execute an echo command and asserts that the output
     * stored in the object is as expected.
     */
    @Test fun executorProperlyStoresOutput() {
        val executor = Executor.ExecutorBuilder("cmd")
            .addArgs("/c", "echo", "somewords")
            .build()

        when(val result = executor.execute()){
            is Executor.Result.Error -> fail(result.data)
            is Executor.Result.Success -> assertEquals("somewords\"", result.data)
        }
    }

    /**
     * Test that [Executor] properly stores any errors associated with the external process.
     *
     * Execute a systeminfo command with an incorrect flag. Assert
     * that an IOException is thrown and that the captured
     * error of expected format.
     */
    @Test fun executorProperlyStoresError() {
        val incorrectFlag = "NotACorrectOption"

        val executor = Executor.ExecutorBuilder("cmd")
            .addArgs("systeminfo", "/fo", incorrectFlag)
            .build()

        val expectedError = "ERROR: Invalid syntax. '$incorrectFlag' value is not allowed for '/fo' option."
        when (val result = executor.execute()) {
            is Executor.Result.Error -> assertTrue(result.data.contains(expectedError))
            is Executor.Result.Success -> TODO()
        }
    }
}
